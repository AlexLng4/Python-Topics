Repository for Python Topics:
Metaclasses:
Task: Implement a custom ORM (Object-Relational Mapping) framework using metaclasses. Design metaclasses that automatically generate database mappings based on class definitions.
Decorators:
Task: Develop a robust logging framework using decorators. Create decorators for logging function calls, measuring execution time, and handling exceptions.
Concurrency and Parallelism:
Task: Build a web scraper using both threading and asyncio. Compare performance and resource usage between the two approaches. Implement advanced synchronization techniques like asyncio.Lock for data consistency.
Descriptors and Properties:
Task: Design a data validation framework using descriptors and properties. Create custom descriptor classes that enforce type checking, range validation, and attribute constraints.
Metaprogramming:
Task: Develop a code generation tool that automatically generates Python classes based on a DSL (Domain-Specific Language). Use metaprogramming techniques to dynamically create class definitions.
Custom Iterators and Generators:
Task: Implement a memory-efficient data processing pipeline using custom iterators and generators. Apply lazy evaluation to process large datasets in a resource-efficient manner.
Context Managers and with Statement:
Task: Create a database connection context manager using the with statement. Ensure proper resource cleanup and exception handling within the context manager.
Type Annotations and Type Hinting:
Task: Refactor a large codebase with comprehensive type annotations. Use mypy to perform static type checking and identify potential type-related issues.
Cython and C Extensions:
Task: Optimize a computationally intensive Python function using Cython. Compile the function to a C extension and measure performance improvements compared to the pure Python implementation.
Function and Class Decorators:
Task: Implement a caching framework using decorators. Create decorators to cache the results of expensive function calls based on arguments and cache expiration policies.
Memory Management:
Task: Profile memory usage of a Python application using memory_profiler. Identify memory hotspots and optimize memory consumption using techniques like object pooling and efficient data structures.
Advanced Python Libraries:
Task: Develop a data analysis pipeline using numpy, pandas, and scikit-learn. Apply feature engineering, model training, and evaluation on a real-world dataset.
Concurrency Libraries:
Task: Build a real-time chat application using asyncio or Twisted. Implement message handling, user authentication, and chat room management with asynchronous I/O.
Performance Optimization:
Task: Profile the performance of a Python application using cProfile and line_profiler. Identify bottlenecks and apply optimizations such as algorithmic improvements and caching.
Design Patterns:
Task: Implement common design patterns (e.g., Singleton, Factory, Observer) in a Python application. Apply these patterns to improve code modularity, extensibility, and maintainability.
